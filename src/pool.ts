/* eslint-disable no-cond-assign */
import assert from 'node:assert'

import { Connection, convertOptions } from './connection'
import { Emitter } from './events'

import type { ConnectionOptions } from './connection'
import type { Logger } from './logger'

/* ========================================================================== *
 * INTERNALS                                                                  *
 * ========================================================================== */

/** A deferred/unwrapped {@link Promise} handling connection requests */
class ConnectionRequest {
  private _resolve!: (connection: Connection) => void
  private _reject!: (error: Error) => void
  private _promise: Promise<Connection>
  private _timeout: NodeJS.Timeout
  private _pending: boolean = true

  /**
   * Create a new {@link ConnectionRequest} with a timeout, after which the
   * request will be automatically rejected.
   */
  constructor(timeout: number) {
    this._promise = new Promise((resolve, reject) => {
      this._resolve = resolve
      this._reject = reject
    })

    this._timeout = setTimeout(() => {
      this._reject(new Error(`Timeout of ${timeout} ms reached acquiring connection`))
      this._pending = false
    }, timeout).unref()
  }

  /** Return the {@link Promise} to the {@link Connection} */
  get promise(): Promise<Connection> {
    return this._promise
  }

  /** Determine whether this request is still pending or not */
  get pending(): boolean {
    return this._pending
  }

  /** Resolve this instance's {@link Promise} with a {@link Connection} */
  resolve(connection: Connection): void {
    clearTimeout(this._timeout)
    if (this._pending) this._resolve(connection)
    this._pending = false
  }

  /** Reject this instance's {@link Promise} with an {@link Error} */
  reject(error: Error): void {
    clearTimeout(this._timeout)
    if (this._pending) this._reject(error)
    this._pending = false
  }
}

/* ========================================================================== *
 * OPTIONS                                                                    *
 * ========================================================================== */

/** Options for our {@link ConnectionPool}. */
export interface ConnectionPoolOptions extends ConnectionOptions{
  /** The minimum number of connections to keep in the pool (default: `0`) */
  minimumPoolSize?: number
  /** The maximum number of connections to keep in the pool (default: `20`) */
  maximumPoolSize?: number
  /**
   * The maximum number of idle clients that can be sitting in the pool.
   *
   * The default value is the average between `minimumPoolSize` and
   * `maximumPoolSize`.
   */
  maximumIdleClients?: number
  /** The number of seconds after which an `acquire()` call will fail (default: `30` sec.) */
  acquireTimeout?: number
  /** The maximum number of seconds a connection can be borrowed for (default: `120` sec.) */
  borrowTimeout?: number
  /** The number of seconds to wait after the creation of a connection failed (default: `5` sec.) */
  createRetryInterval?: number
}

/** Statistical informations about a {@link ConnectionPool} */
export interface ConnectionPoolStats {
  /** The number of {@link Connection}s currently available in the pool */
  available: number,
  /** The number of {@link Connection}s currently borrowed out by the pool */
  borrowed: number,
  /** The number of {@link Connection}s currently connecting */
  connecting: number,
  /** The total number of {@link Connection}s managed by the pool */
  total: number,
}

/** Events generated by our {@link ConnectionPool} */
interface ConnectionPoolEvents {
  started: () => unknown,
  stopped: () => unknown,

  connection_created: (connection: Connection) => unknown,
  connection_destroyed: (connection: Connection) => unknown,
  connection_acquired: (connection: Connection) => unknown,
  connection_released: (connection: Connection) => unknown,
}

/* ========================================================================== *
 * CONNECTION POOL                                                            *
 * ========================================================================== */

export class ConnectionPool extends Emitter<ConnectionPoolEvents> {
  /** Our {@link Logger}  */
  private readonly _logger: Logger
  /** Borrowed connections mapped to their borrow timeout */
  private readonly _borrowed = new Map<Connection, NodeJS.Timeout>()
  /** Array of all _available_ connections (that is, not borrowed out) */
  private readonly _available: Connection[] = []
  /** Array of all pending {@link ConnectionRequest}s */
  private readonly _pending: ConnectionRequest[] = []
  /** A {@link Set} containing all managed {@link Connections} */
  private readonly _connections = new Set<Connection>()

  /** The minimum number of connections to keep in the pool */
  private readonly _minimumPoolSize: number
  /** The maximum number of connections to keep in the pool */
  private readonly _maximumPoolSize: number
  /** The maximum number of idle clients that can be sitting in the pool */
  private readonly _maximumIdleClients: number
  /** The number of *milliseconds* after which an `acquire()` call will fail */
  private readonly _acquireTimeoutMs: number
  /** The maximum number of *milliseconds* a connection can be borrowed for */
  private readonly _borrowTimeoutMs
  /** The number of *milliseconds* to wait after the creation of a connection failed */
  private readonly _createRetryIntervalMs
  /** The {@link ConnectionOptions} converted into a string for `LibPQ` */
  private readonly _connectionOptions: string

  /** Indicator on whether this {@link ConnectionPool} was started or not */
  private _started: boolean = false

  /** Create a new {@link ConnectionPool} with the specified options */
  constructor(logger: Logger, options: ConnectionPoolOptions) {
    super()

    const {
      minimumPoolSize = 0,
      maximumPoolSize = 20,
      maximumIdleClients = (maximumPoolSize + minimumPoolSize) / 2,
      acquireTimeout = 30,
      borrowTimeout = 120,
      createRetryInterval = 5,
      ...connectionOptions
    } = options

    this._minimumPoolSize = Math.round(minimumPoolSize)
    this._maximumPoolSize = Math.round(maximumPoolSize)
    this._maximumIdleClients = Math.ceil(maximumIdleClients)
    this._acquireTimeoutMs = Math.round(acquireTimeout * 1000)
    this._borrowTimeoutMs = Math.round(borrowTimeout * 1000)
    this._createRetryIntervalMs = Math.round(createRetryInterval * 1000)

    assert(this._minimumPoolSize >= 0, `Invalid minimum pool size: ${this._minimumPoolSize}`)
    assert(this._maximumPoolSize >= 1, `Invalid maximum pool size: ${this._maximumPoolSize}`)
    assert(this._maximumIdleClients > 0, `Invalid maximum idle clients: ${this._maximumIdleClients}`)
    assert(this._acquireTimeoutMs > 0, `Invalid acquire timeout: ${this._acquireTimeoutMs} ms`)
    assert(this._borrowTimeoutMs > 0, `Invalid borrow timeout: ${this._borrowTimeoutMs} ms`)
    assert(this._createRetryIntervalMs > 0, `Invalid create retry interval: ${this._createRetryIntervalMs} ms`)

    assert(this._minimumPoolSize <= this._maximumPoolSize,
        `The minimum pool size ${this._minimumPoolSize} must less or equal to the maximum pool size ${this._maximumPoolSize}`)
    assert(this._minimumPoolSize <= this._maximumIdleClients,
        `The minimum pool size ${this._minimumPoolSize} must less or equal to the maximum number of idle clients ${this._maximumIdleClients}`)
    assert(this._maximumIdleClients <= this._maximumPoolSize,
        `The maximum number of idle clients ${this._maximumIdleClients} must less or equal to the maximum pool size ${this._maximumPoolSize}`)

    this._connectionOptions = convertOptions(connectionOptions)
    this._logger = logger
  }

  /** Statistical informations about a {@link ConnectionPool} */
  get stats(): ConnectionPoolStats {
    const available = this._available.length
    const borrowed = this._borrowed.size
    const total = this._connections.size
    const connecting = total - (available + borrowed)
    return { available, borrowed, connecting, total }
  }

  /* ===== CONNECTION LIFECYCLE ============================================= */

  /** Create a connection */
  protected _create(logger: Logger, options: string): Connection {
    return new Connection(logger, options)
  }

  /** Validate a connection by issuing a super-simple statement */
  protected async _validate(connection: Connection): Promise<boolean> {
    if (! connection.connected) return false

    try {
      const result = await connection.query('SELECT now()')
      return result.rowCount === 1
    } catch (error: any) {
      this._logger.error(`Error validating connection "${connection.id}"`, error)
      return false
    }
  }

  /** Recycle a connection rolling back any running transaction */
  protected async _recycle(connection: Connection): Promise<boolean> {
    if (! connection.connected) return false

    try {
      const result = await connection.query('SELECT pg_current_xact_id_if_assigned() IS NOT NULL')
      if (result.rows[0]?.[0] === 't') {
        this._logger.warn(`Rolling back transaction recycling connection "${connection.id}"`)
        await connection.query('ROLLBACK')
      }
      return true
    } catch (error: any) {
      this._logger.error(`Error recycling connection "${connection.id}"`, error)
      return false
    }
  }

  /** Destroy a connection, it will be wiped from this pool */
  protected _destroy(connection: Connection): void {
    if (! this._connections.delete(connection)) return
    this._logger.info(`Destroying connection "${connection.id}"`)

    /* Wipe an borrowing details if the connection is borrowed */
    clearTimeout(this._borrowed.get(connection))
    this._borrowed.delete(connection)

    /* Remove from the available pool, if found there */
    const index = this._available.indexOf(connection)
    if (index >= 0) this._available.splice(index)

    /* If we know this connection, force disconnection */
    connection.destroy()
    this._emit('connection_destroyed', connection)
  }

  /* ===== RUN LOOPS ======================================================== */

  /**
   * Run the create connection loop.
   *
   * This loop simply creates connections, connects them, sets up the various
   * event handler (on disconnect) and simply adds them to the available array.
   */
  private _runCreateLoop(): void {
    if (! this._started) return

    process.nextTick(() => {
      /* Do we need to (or should we) create a new connection? We don't want
       * to run in a while loop, as if "connect" fails, we want to delay the
       * retrial of the amount specified in the pool construction options */
      const connections = this._connections.size
      const available = this._available.length

      if ((available && (connections >= this._minimumPoolSize)) ||
          (connections >= this._maximumPoolSize)) {
        return
      }

      /* ===== STEP 1: create a connection ================================== */

      let connection: Connection
      try {
        connection = this._create(this._logger, this._connectionOptions)
      } catch (error) {
        this._logger.error('Error creating pooled connection', error)
        /* Run the create loop, again, but only our retry interval has elapsed */
        setTimeout(() => this._runCreateLoop(), this._createRetryIntervalMs).unref()
        return
      }

      /* ===== STEP 2: setup event handlers ================================= */

      /* Dispose of the connection when the pool is stopped */
      const evictor = (): void => this._destroy(connection)
      this.once('stopped', evictor)

      /* Dispose of the connection when the connection is closed */
      connection.once('destroyed', () => {
        this.off('stopped', evictor)
        this._destroy(connection)
        this._runCreateLoop()
      })

      /* Remember this connection, always... */
      this._connections.add(connection)

      /* ===== STEP 3: connect the connection =============================== */

      connection.connect().then(() => {
        /* The pool might have been stopped while connecting... */
        if (this._started) this._available.push(connection)
        else this._destroy(connection)

        /* Run our loops */
        this._runCreateLoop()
        this._runBorrowLoop()

        /* We have created a connection in this pool */
        this._emit('connection_created', connection)
      }).catch((error) => {
        this._logger.error(`Error connecting "${connection.id}"`, error)
        /* Run the create loop, again, but only our retry interval has elapsed */
        setTimeout(() => this._runCreateLoop(), this._createRetryIntervalMs).unref()
      })
    })
  }

  /**
   * Run the borrow connection loop.
   *
   * This loop looks at all the pending connection requests, and fullfills them
   * with a connection from the available array. If no connections are available
   * then it simply triggers the create loop.
   */
  private _runBorrowLoop(): void {
    if (! this._started) return

    process.nextTick(() => Promise.resolve().then(async () =>{
      let request: ConnectionRequest | undefined
      while (request = this._pending.splice(0, 1)[0]) {
        /* This request might not be pending, it might have timed out */
        if (! request.pending) continue

        /* Check if a connection is available, if not, run the create loop */
        const connection = this._available.splice(0, 1)[0]
        if (! connection) {
          this._pending.unshift(request)
          return this._runCreateLoop()
        }

        /* If a connection is available, it should be validated on borrow */
        const valid = await this._validate(connection)

        /* The pool might have been stopped while validating, simply return
         * and let the "stopped" event handler do its job */
        if (! this._started) return

        /* The connection was not valid, disconnect it and try again */
        if (! valid) {
          /* Any pending request goes back at the beginning of the queue */
          if (request.pending) this._pending.unshift(request)
          this._destroy(connection) // will trigger the "disconnected" event
          continue
        }

        /* While validating, the request might have been timed out */
        if (! request.pending) {
          /* If the request is not pending anymore, just release this
           * connection. This might trigger an extra validation/recycle,
           * but it's definitely better than throwing this away */
          this.release(connection)
          continue
        }

        /* The connection is valid, and the request is pending. Borrow out
         * this connection to fullfill the request, after setting up our
         * borrowing timeout */
        const timeout = setTimeout(() => {
          this._logger.error(`Connection "${connection.id}" borrowed for too long`)
          this._destroy(connection) // will trigger the "disconnected" event
        }, this._borrowTimeoutMs).unref()

        /* Remember this timeout in our borrow list */
        this._borrowed.set(connection, timeout)

        /* Lift-off! */
        this._emit('connection_acquired', connection)
        request.resolve(connection)
      }
    }).catch((error) => {
      this._logger.error('Error running pool', error)
    }))
  }

  /* ===== CONNECTION MANAGEMENT ============================================ */

  /** Acquire a {@link Connection} from this {@link ConnectionPool} */
  acquire(): Promise<Connection> {
    assert(this._started, 'Connection pool not started')

    /* Add a new entry to our pending connection requests and run the loop */
    const deferred = new ConnectionRequest(this._acquireTimeoutMs)
    this._pending.push(deferred)
    this._runBorrowLoop()

    /* Return the deferred connection's promise */
    return deferred.promise
  }

  /** Release a {@link Connection} back to this {@link ConnectionPool} */
  release(connection: Connection): void {
    /* Ensure this is _our_ connection */
    assert(this._connections.has(connection), `Connection "${connection.id}" not owned by pool`)

    Promise.resolve().then(async () => {
      this._logger.info(`Releasing connection "${connection.id}"`)

      /* Clear up any borrow timeout, and remove from borrowed */
      clearTimeout(this._borrowed.get(connection))

      /* If the connection is not connected, discard it */
      if (! connection.connected) {
        this._logger.info(`Disconnected connection "${connection.id}" discarded`)
        this._destroy(connection)

      /* If we have enough available connections, discard it */
      } else if (this._available.length > this._maximumIdleClients) {
        this._logger.info(`Extra connection "${connection.id}" discarded`)
        this._destroy(connection)

      /* If the connection is not valid, discard it */
      } else if (! await this._recycle(connection)) {
        this._logger.info(`Non-validated connection "${connection.id}" discarded`)
        this._destroy(connection)

      /* If the connection is valid, try to recycle it */
      } else {
        this._logger.debug(`Connection "${connection.id}" released`)
        this._borrowed.delete(connection) // delete from the borrow list
        this._available.push(connection) // add to the available list
        this._emit('connection_released', connection)
      }

    /* Any error might come from trying to validate/recycle the connection */
    }).catch((error) => {
      this._logger.error(`Error releasing connection "${connection.id}"`, error)
      this._destroy(connection)

    /* Regardless of whatever happened, always run our borrow loop */
    }).finally(() => this._runBorrowLoop())
  }

  /* ===== POOL LIFECYCLE =================================================== */

  /** Start this {@link ConnectionPool} validating an initial connection */
  async start(): Promise<this> {
    if (this._started) return this

    try {
      this._logger.info('Starting connection pool')
      this._started = true

      /* Acquire a connection through our loops */
      const connection = await this.acquire()
      this.release(connection)
      this._emit('started')
      return this
    } catch (error) {
      await this.stop()
      throw error
    }
  }

  /** Stop this {@link ConnectionPool} and disconnect all connections. */
  stop(): Promise<void> {
    if (! this._started) return Promise.resolve()
    this._started = false

    this._logger.info(`Stopping connection pool with ${this._connections.size} connections`)

    /* Create promises awaiting for all our connections to be disconnected */
    const promises = [ ...this._connections ].map((connection) => {
      if (connection.connected) {
        return new Promise<boolean>((resolve) => {
          connection.once('destroyed', (error?: Error): void => {
            if (! error) return resolve(false)
            this._logger.warn(`Error disconnecting "${connection.id}"`, error)
            return resolve(true)
          })
        })
      } else return Promise.resolve(false)
    })


    /* Reject any pending acquisition */
    for (const pending of this._pending) {
      pending.reject(new Error('Connection pool stopped'))
    }

    /* Let the "stopped" event handler close up all connections */
    this._available.splice(0, Number.MAX_SAFE_INTEGER)
    this._borrowed.clear()
    this._emit('stopped')

    /* Await on all our promises and see if we have any leftovers */
    return Promise.all(promises).then((results) => {
      const sum = results.reduce((sum, failed) => sum + (failed ? 1 : 0), 0)
      assert(sum === 0, `Error disconnecting ${sum} connections`)
      this._logger.info('Connection pool stopped')
    })
  }
}
